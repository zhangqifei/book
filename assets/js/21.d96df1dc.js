(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{368:function(e,s,n){"use strict";n.r(s);var t=n(43),a=Object(t.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"linux磁盘管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linux磁盘管理"}},[e._v("#")]),e._v(" Linux磁盘管理")]),e._v(" "),n("p",[e._v("Linux系统一切以文件的方式存储于硬盘中，应用程序数据需要时刻读写磁盘，所以企业生产环境对硬盘的操作变得尤为重要，对硬盘的和管理也是每个运维工程师必备的工作之一。")]),e._v(" "),n("h2",{attrs:{id:"计算机硬盘简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#计算机硬盘简介"}},[e._v("#")]),e._v(" 计算机硬盘简介")]),e._v(" "),n("p",[e._v("硬盘是计算机主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成，碟片外覆盖有铁磁性材料，硬盘内部有磁道、柱面、扇区、磁头等部分组成。")]),e._v(" "),n("p",[e._v("Linux 系统中硬件设备相关配置文件存放在/dev/下，常见硬盘命名为/dev/hda、/dev/sda、/dev/sdb、/dev/sdc、/dev/vda。不同硬盘接口，在系统中识别的设备名称不一样。")]),e._v(" "),n("p",[e._v("IDE硬盘接口在Linux中设备名为/dev/hda,SAS、SCSL、SATA硬盘接口在Linux中设备名为sda，高效云盘硬盘接口会识别为/dev/vda等。")]),e._v(" "),n("p",[e._v("文件存储在硬盘上，硬盘的最小存储单位叫作sector（扇区），每个sector存储512字节。操作系统在读取硬盘的时候，不会逐个sector地去读取，这样效率非常低，为了提升读取效率，操作系统会一次性连续读取多个sector，即一次性读取多个sector称为一个block（块）。")]),e._v(" "),n("p",[e._v("有多个sector组成的block是文件存取的最小单位。block的大小常见的有1KB、2KB、4KB，block在linux中常设置为4KB，即连续8个sector组成一个block。")]),e._v(" "),n("p",[e._v("/boot分区的block一般为1KB，而/deta/分区或者/分区的block为4KB。可以通过以下3中方法查看Linux分区的block大小：")]),e._v(" "),n("p",[n("strong",[e._v("查看block的方法")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    // ext3与ext4格式化文件系统\n    [root@localhost ~]# stat /boot/ |grep "IO Block"\n    Size: 4096            Blocks: 8          IO Block: 4096   directory\n    [root@localhost ~]# dumpe2fs /dev/vda1 |grep "Block size"\n    dumpe2fs 1.42.9 (28-Dec-2013)\n    Block size:               4096\n    [root@localhost ~]# tune2fs -l /dev/vda1 |grep "Block size"\n    Block size:               4096\n\n    // xfs格式化文件系统：\n    xfs_info /dev/sda1\n')])])]),n("blockquote",[n("p",[e._v("Linux stat命令用于显示inode内容。stat以文字的格式来显示inode的内容。"),n("br")])]),e._v(" "),n("blockquote",[n("p",[e._v("dumpe2fs用来查询文件系统状态。dumpe2fs命令用于打印“ext2/ext3”文件系统的超级块和快组信息。"),n("br")])]),e._v(" "),n("blockquote",[n("p",[e._v("tune2fs是调整和查看ext2/ext3文件系统的文件系统参数，Windows下面如果出现意外断电死机情况，下次开机一般都会出现系统自检。Linux系统下面也有文件系统自检，而且是可以通过tune2fs命令，自行定义自检周期及方式。")])]),e._v(" "),n("p",[e._v("例如创建一个普通文件，文件大小为10B，而默认设置block为4KB如果有一万个小文件，由于每个Block只能存放一个文件，如果文件的大小比Block大，会申请更多Block，相反如果文件的大小比默认Block小，仍然占用一个Block，这样剩余的空间会被浪费掉。")]),e._v(" "),n("p",[n("strong",[e._v("详细说明：")])]),e._v(" "),n("p",[e._v("一万个文件理论只占用空间大小:10000*10=100000B="),n("strong",[e._v("97.65625MB")])]),e._v(" "),n("p",[e._v("一万个文件真实占用空间大小:10000*4096B=40960000B=40000MB="),n("strong",[e._v("40GB")])]),e._v(" "),n("p",[e._v("此时可以根据实际需求将会Block设置为1KB，从而节省更多的空间。")]),e._v(" "),n("h2",{attrs:{id:"硬盘block及inode详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#硬盘block及inode详解"}},[e._v("#")]),e._v(" 硬盘block及inode详解")]),e._v(" "),n("p",[e._v("操作系统对于文件数据的存放包括两个部分：1、文件内容，2、权限及文件属性")]),e._v(" "),n("p",[e._v("在硬盘分区中，还有一个超级区块（superblock）")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("superblock：记录文件系统的整体信息，包括inode与block的总量、使用大小、剩余大小以及文件系统的格式与相关信息等")])]),e._v(" "),n("li",[n("p",[e._v("inode：记录文件的属性、权限，同时会记录该文件的数据所在的block编号")])]),e._v(" "),n("li",[n("p",[e._v("block：存储文件的内容")])])]),e._v(" "),n("p",[e._v("每个inode与block都有编号，而每个文件都会占用一个inode，inode内则有文件数据放置的block号码；能够找到文件的inode就可以找到该文件所放置数据的block号码，从而读取文件内容。")]),e._v(" "),n("p",[e._v("操作系统进行格式化分区时，操作系统自动将硬盘分为两个区域。一个是数据block区，用于存放文件数据；另一个是inode table区，用于存放inode包含的元素信息。")]),e._v(" "),n("p",[e._v("每个inode节点的大小，可以在格式化时指定，默认为128B或256B，/boot分区inode默认为128B，其他分区默认为256B。")]),e._v(" "),n("p",[n("strong",[e._v("查看Linux系统inode方法")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    ext3与ext4格式化文件系统\n    [root@localhost ~]# dumpe2fs /dev/vda1 | grep "Inode size" \n    dumpe2fs 1.42.9 (28-Dec-2013)\n    Inode size:               256\n\n    [root@localhost ~]# tune2fs -l /dev/vda1 | grep "Inode size" \n    Inode size:               256\n\n    xfs格式化文件系统\n    xfs_info /dev/vda1\n')])])]),n("p",[e._v("在格式化时可以指定默认的inode与block的大小；-b指定默认block值，-I指定默认inode值，例："),n("code",[e._v("mkfs.ext4 –b 4096 –I 256 /dev/sdb")])]),e._v(" "),n("h3",{attrs:{id:"linux文件访问流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linux文件访问流程"}},[e._v("#")]),e._v(" Linux文件访问流程")]),e._v(" "),n("img",{attrs:{src:e.$withBase("/disk/1.png"),alt:"Linux文件访问流程"}}),e._v(" "),n("h3",{attrs:{id:"磁盘的容量由inode和block共同决定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#磁盘的容量由inode和block共同决定"}},[e._v("#")]),e._v(" 磁盘的容量由inode和block共同决定")]),e._v(" "),n("img",{attrs:{src:e.$withBase("/disk/2.png"),alt:"磁盘的容量由inode和block共同决定"}}),e._v(" "),n("h3",{attrs:{id:"有关inode的总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#有关inode的总结"}},[e._v("#")]),e._v(" 有关inode的总结")]),e._v(" "),n("ol",[n("li",[e._v("磁盘格式化创建文件系统时会生成一定数量的inode和block；")]),e._v(" "),n("li",[e._v("inode称为索引节点，作用是存放文件的属性信息和指向block的指针；")]),e._v(" "),n("li",[e._v("inode是磁盘上的一块存储空间，CentOS6默认inode大小为256字节；")]),e._v(" "),n("li",[e._v("inode编号是唯一的，不同的文件有唯一的inode号；")]),e._v(" "),n("li",[e._v("inode号相同的文件互为硬链接；")]),e._v(" "),n("li",[e._v("创建一个文件至少要占用一个inode和一个block；")]),e._v(" "),n("li",[e._v("查看inode总量和使用量 "),n("code",[e._v("df -i")]),e._v("；")]),e._v(" "),n("li",[e._v("查看文件的inode信息 ls -li 或 stat /etc/hosts；")]),e._v(" "),n("li",[e._v("生成指定的大小的inode "),n("code",[e._v("mkfs.ext4 -b 2048 -I 256 /dev/sdb")]),e._v("。")])]),e._v(" "),n("h3",{attrs:{id:"有关block的总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#有关block的总结"}},[e._v("#")]),e._v(" 有关block的总结")]),e._v(" "),n("ol",[n("li",[e._v("磁盘存取文件是按block为单位存取的；")]),e._v(" "),n("li",[e._v("一个文件可能占用多个block，但是每读取一个block就会消耗一次磁盘I/O；")]),e._v(" "),n("li",[e._v("如果要提升磁盘IO性能，那么block应该大一点，从而能读取更多内容；")]),e._v(" "),n("li",[e._v("block太大，存放小文件就会造成空间浪费；block太小，又会消耗磁盘IO；")]),e._v(" "),n("li",[e._v("要根据业务需求确定block大小，一般默认设置为4K；")]),e._v(" "),n("li",[e._v("block大小也是格式化时确定的，命令是 "),n("code",[e._v("mkfs.ext4 -b 2048 -I 256 /dev/sdb")]),e._v("。")])]),e._v(" "),n("h3",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("ol",[n("li",[e._v("磁盘格式化文件系统后，会分为inode和block两部分；")]),e._v(" "),n("li",[e._v("inode存放文件属性和指向block的指针；")]),e._v(" "),n("li",[e._v("文件名和inode对应关系存放在上级目录里的block；")]),e._v(" "),n("li",[e._v("inode默认256B，block默认4K；")]),e._v(" "),n("li",[e._v("通过"),n("code",[e._v("df -i")]),e._v(" 查看inode数量及使用量；")]),e._v(" "),n("li",[e._v("查看 inode和block大小 "),n("code",[e._v('dumpe2fs /dev/sda1 | egrep "Inode size|Block size"')]),e._v("；")]),e._v(" "),n("li",[e._v("一个文件至少占用一个inode和block，硬链接占用同一个inode；")]),e._v(" "),n("li",[e._v("一个block只能被一个文件使用，block太小，性能差，block太大，浪费空间；")]),e._v(" "),n("li",[e._v("通常，一块空间能放多少文件取决于inode和block的数量和大小，如果文件很小，那么block或inode就容易耗尽；如果文件很大，则应该用block的总数除以一个文件占用的block的数量得出存放文件的数目。")])]),e._v(" "),n("h2",{attrs:{id:"硬链接与软链接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#硬链接与软链接"}},[e._v("#")]),e._v(" 硬链接与软链接")]),e._v(" "),n("p",[e._v("下面用一个实例来说明硬链接和软链接。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("现在目录下有两个文件，一个名为AAA，一个名为BBB。\n引用\n[root@centos7 app]#ls -il\ntotal 0\n67 -rw-r--r--. 1 root root 8 Nov 18 19:41 AAA\n68 -rw-r--r--. 1 root root 0 Nov 18 19:41 BBB\n\n首先先做一个AAA的硬链接。\n引用\n[root@centos7 app]#ln AAA AAAhard      \n[root@centos7 app]#ls -il     \n67 -rw-r--r--. 2 root root 8 Nov 18 19:41 AAA\n67 -rw-r--r--. 2 root root 8 Nov 18 19:41 AAAhard\n68 -rw-r--r--. 1 root root 0 Nov 18 19:41 BBB\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br")])]),n("p",[e._v("这里我们注意在创建链接前，AAA显示的链接数目为1，创建链接后")]),e._v(" "),n("ol",[n("li",[e._v("AAA和AAAhard的链接数目都变为2。")]),e._v(" "),n("li",[e._v("AAA和AAAhard的inode号是一样的，都是67。")]),e._v(" "),n("li",[e._v("AAA和AAAhard显示的文件大小也是一样，都是8B。\n可见进行了ln命令的操作结果：AAA和AAAhard是同一个文件的两个名字， 它们具有同样的索引节点号和文件属性，建立文件AAA的硬链接，就是为 AAA的文件索引节点在当前目录上建立一个新指针。你可以删除其中任何一个，如rm AAA，每次只会删除一个指针，链接数同时减一，只有将所有指向文件内容的指针，也即链接数减为0时，内核才会把文件内容从磁盘上删除。")])]),e._v(" "),n("p",[e._v("尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一些不足之处：")]),e._v(" "),n("ol",[n("li",[e._v("不允许给目录创建硬链接。")]),e._v(" "),n("li",[e._v("不可以在不同文件系统的文件间建立链接。因为 inode 是这个文件在当前分区中的索引值，是相对于这个分区的，当然不能跨越文件系统了。")])]),e._v(" "),n("p",[e._v("接着我们做一个指向BBB的软链接，软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("引用\n[root@centos7 app]#ln -s BBB BBBsoft\n[root@centos7 app]#ls -il\n67 -rw-r--r--. 2 root root 8 Nov 18 19:44 AAA\n67 -rw-r--r--. 2 root root 8 Nov 18 19:44 AAAhard\n68 -rw-r--r--. 1 root root 0 Nov 18 19:41 BBB\n69 lrwxrwxrwx. 1 root root 3 Nov 18 19:46 BBBsoft -> BBB\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[e._v("从上面链接后的结果可以看出来软链接与硬链接，区别不仅仅是在概念上，在实现上也是完全不同的。")]),e._v(" "),n("p",[n("strong",[e._v("区别：")])]),e._v(" "),n("ol",[n("li",[e._v("硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件；")]),e._v(" "),n("li",[e._v("在文件属性上软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等关系；")]),e._v(" "),n("li",[e._v("链接数目是不一样的，软链接的链接数目不会增加；")]),e._v(" "),n("li",[e._v("文件大小是不一样的，硬链接文件显示的大小是跟原文件是一样的。而这里软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B。因为BBB共有3个字符")]),e._v(" "),n("li",[e._v("软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接")])]),e._v(" "),n("p",[e._v("总之，建立软链接就是建立了一个新文件。当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。")]),e._v(" "),n("p",[e._v("当然软链接也有硬链接没有的缺点：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，")]),e._v(" "),n("h2",{attrs:{id:"linux下磁盘实战操作命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linux下磁盘实战操作命令"}},[e._v("#")]),e._v(" Linux下磁盘实战操作命令")]),e._v(" "),n("p",[e._v("由于硬盘常年大量读写，经常会出现坏盘，需要更换硬盘，或者由于磁盘空间不足，需要添加新硬盘，新添加的硬盘需要经过格式化、分区才能被Linux系统所使用。")]),e._v(" "),n("p",[e._v("服务器添加一块新硬盘，不需要关机，直接插入即可，一般硬盘均支持热插拔功能。")]),e._v(" "),n("p",[n("strong",[e._v("下面是添加新硬盘的操作流程")])]),e._v(" "),n("p",[e._v("检测Linux系统识别的硬盘设备，新添加地硬盘一般会被识别为/dev/sdb,如果有多块硬盘，会依次识别为/dev/sdc、/dev/sdd等设备名称。")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("查看是否有新添加的硬盘")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# fdisk -l\n\n Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors\n Units = sectors of 1 * 512 = 512 bytes\n Sector size (logical/physical): 512 bytes / 512 bytes\n I/O size (minimum/optimal): 512 bytes / 512 bytes\n Disk label type: dos\n Disk identifier: 0x000cd1e5\n\n Device Boot      Start         End      Blocks   Id  System\n /dev/sda1   *        2048     2099199     1048576   83  Linux\n /dev/sda2         2099200    83886079    40893440   8e  Linux LVM\n\n Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors  # 这里多一个 Disk /dev/sdb: 21.5 GB\n Units = sectors of 1 * 512 = 512 bytes\n Sector size (logical/physical): 512 bytes / 512 bytes\n I/O size (minimum/optimal): 512 bytes / 512 bytes\n")])])])])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("这里显示fdisk的各个参数的用法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  a   toggle a bootable flag # 活动分区标记/引导分区\n  b   edit bsd disklabel # 编辑bsd disklabel\n  c   toggle the dos compatibility flag # 切换dos兼容性标志\n  d   delete a partition # 删除分区\n  g   create a new empty GPT partition table # 创建一个新的空GPT分区表\n  G   create an IRIX (SGI) partition table # 创建一个IRIX（SGI）分区表\n  l   list known partition types # 显示分区类型\n  m   print this menu # 显示菜单和帮助信息\n  n   add a new partition # 新建分区\n  o   create a new empty DOS partition table # 创建一个新空DOS分区表\n  p   print the partition table # 显示分区信息\n  q   quit without saving changes # 退出不保存\n  s   create a new empty Sun disklabel # 创建一个新的空的sun磁盘标签\n  t   change a partition's system id # 设置分区号\n  u   change display/entry units # 更改显示/输入单位\n  v   verify the partition table # 进行扥去检查\n  w   write table to disk and exit # 保存修改\n  x   extra functionality (experts only) # 扩展应用，高级功能\n")])])])])]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[e._v("基于新硬盘/dev/sdb设备，创建磁盘分区/dev/sdb1 ，创建/dev/sdb1分区方法，执行命令"),n("code",[e._v("fdisk /dev/sdb")]),e._v(",然后按屏幕提示依次输入n、p、1、按enter键，在输入+10G，在按enter键，输入w，最后执行"),n("code",[e._v("fdisk -l")]),e._v("在查看一下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# fdisk /dev/sdb \n Welcome to fdisk (util-linux 2.23.2).\n\n Changes will remain in memory only, until you decide to write them.\n Be careful before using the write command.\n\n Device does not contain a recognized partition table\n Building a new DOS disklabel with disk identifier 0x33ae5fdc.\n\n Command (m for help): m\n Command action\n a   toggle a bootable flag\n b   edit bsd disklabel\n c   toggle the dos compatibility flag\n d   delete a partition\n g   create a new empty GPT partition table\n G   create an IRIX (SGI) partition table\n l   list known partition types\n m   print this menu\n n   add a new partition\n o   create a new empty DOS partition table\n p   print the partition table\n q   quit without saving changes\n s   create a new empty Sun disklabel\n t   change a partition's system id\n u   change display/entry units\n v   verify the partition table\n w   write table to disk and exit\n x   extra functionality (experts only)\n\n Command (m for help): n\n Partition type:\n p   primary (0 primary, 0 extended, 4 free)\n e   extended\n Select (default p): p\n Partition number (1-4, default 1): 1\n First sector (2048-41943039, default 2048): \n Using default value 2048\n Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +10G\n Partition 1 of type Linux and of size 10 GiB is set\n\n Command (m for help): w\n The partition table has been altered!\n\n Calling ioctl() to re-read partition table.\n Syncing disks.\n")])])])])]),e._v(" "),n("hr"),e._v(" "),n("ul",[n("li",[n("p",[e._v("查看是否成功创建磁盘分区/dev/sdb1\n[root@localhost ~]# fdisk -l")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors\n  Units = sectors of 1 * 512 = 512 bytes\n  Sector size (logical/physical): 512 bytes / 512 bytes\n  I/O size (minimum/optimal): 512 bytes / 512 bytes\n  Disk label type: dos\n  Disk identifier: 0x000cd1e5\n\n  Device Boot      Start         End      Blocks   Id  System\n  /dev/sda1   *        2048     2099199     1048576   83  Linux\n  /dev/sda2         2099200    83886079    40893440   8e  Linux LVM\n\n  Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors\n  Units = sectors of 1 * 512 = 512 bytes\n  Sector size (logical/physical): 512 bytes / 512 bytes\n  I/O size (minimum/optimal): 512 bytes / 512 bytes\n  Disk label type: dos\n  Disk identifier: 0x33ae5fdc\n\n  Device Boot      Start         End      Blocks   Id  System\n  /dev/sdb1            2048    20973567    10485760   83  Linux  # /dev/sdb1 创建出来了，大小10G\n")])])])])]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[e._v("执行"),n("code",[e._v("mkfs.ext4 /dev/sdb1")]),e._v(" 格式化磁盘分区")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# mkfs.ext4 /dev/sdb1 \n mke2fs 1.42.9 (28-Dec-2013)\n Filesystem label=\n OS type: Linux\n Block size=4096 (log=2)\n Fragment size=4096 (log=2)\n Stride=0 blocks, Stripe width=0 blocks\n 655360 inodes, 2621440 blocks\n 131072 blocks (5.00%) reserved for the super user\n First data block=0\n Maximum filesystem blocks=2151677952\n 80 block groups\n 32768 blocks per group, 32768 fragments per group\n 8192 inodes per group\n Superblock backups stored on blocks: \n         32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632\n\n Allocating group tables: done                            \n Writing inode tables: done                            \n Creating journal (32768 blocks): done\n Writing superblocks and filesystem accounting information: done \n")])])])]),e._v(" "),n("li",[n("p",[e._v("/dev/sdb1分区格式化，使用mount命令挂载/data/目录，并将挂载分区命令写入/etc/fstab文件中，开机启动")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" # 创建/data/数据目录\n [root@localhost ~]# mkdir /data \n\n # 挂载/dev/sdb1 分区至/data/目录\n [root@localhost ~]# mount /dev/sdb1  /data/\n\n # 将挂载分区命令写入/etc/fstab文件中，开机启动\n [root@localhost ~]# echo '/dev/sdb1 /data ext4 defaults 0 0' >> /etc/fstab\n\n #`df -h`查看挂载是否成功\n [root@localhost ~]# df -h\n Filesystem               Size  Used Avail Use% Mounted on\n /dev/mapper/centos-root   36G  1.5G   35G   4% /\n devtmpfs                 735M     0  735M   0% /dev\n tmpfs                    747M     0  747M   0% /dev/shm\n tmpfs                    747M  9.5M  737M   2% /run\n tmpfs                    747M     0  747M   0% /sys/fs/cgroup\n /dev/sda1               1014M  130M  885M  13% /boot\n tmpfs                    150M     0  150M   0% /run/user/0\n /dev/sdb1                9.8G   37M  9.2G   1% /data\n")])])])])]),e._v(" "),n("h2",{attrs:{id:"基于gpt格式磁盘分区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基于gpt格式磁盘分区"}},[e._v("#")]),e._v(" 基于GPT格式磁盘分区")]),e._v(" "),n("p",[e._v("MBR分区标准决定了MBR只支持在2TB以下的硬盘分区，为了能支持使用大于2TB硬盘空间，需要GPT格式进行分区。创建大于2TB的分区，需要使用parted工具。")]),e._v(" "),n("p",[e._v("通常服务器有多块硬盘，整个硬盘容量为10TB,需要基于GTP格式对10TB硬盘进行分区，操作如下：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("查看是新添加的硬盘/dev/sdc，假设有10TB")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# fdisk -l\n\n Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors\n Units = sectors of 1 * 512 = 512 bytes\n Sector size (logical/physical): 512 bytes / 512 bytes\n I/O size (minimum/optimal): 512 bytes / 512 bytes\n Disk label type: dos\n Disk identifier: 0x000cd1e5\n\n Device Boot      Start         End      Blocks   Id  System\n /dev/sda1   *        2048     2099199     1048576   83  Linux\n /dev/sda2         2099200    83886079    40893440   8e  Linux LVM\n\n Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors\n Units = sectors of 1 * 512 = 512 bytes\n Sector size (logical/physical): 512 bytes / 512 bytes\n I/O size (minimum/optimal): 512 bytes / 512 bytes\n Disk label type: dos\n Disk identifier: 0x33ae5fdc\n\n Device Boot      Start         End      Blocks   Id  System\n /dev/sdb1            2048    20973567    10485760   83  Linux\n\n Disk /dev/sdc: 21.5 GB, 21474836480 bytes, 41943040 sectors   # 这里新添加一个Disk /dev/sdc: 21.5 GB\n Units = sectors of 1 * 512 = 512 bytes\n Sector size (logical/physical): 512 bytes / 512 bytes\n I/O size (minimum/optimal): 512 bytes / 512 bytes\n")])])])])]),e._v(" "),n("blockquote",[n("p",[e._v("虚拟机先添加的硬盘不显示需要执行"),n("code",[e._v('echo "- - -" > /sys/class/scsi_host/host0/scan')]),e._v("命令使主机识别新增的硬盘。")])]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[e._v("设置分区类型为gpt格式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" # 设置分区类型为gpt格式\n [root@localhost ~]# parted -s /dev/sdc mklabel gpt\n\n # 查看是否成功设置为gpt格式\n [root@localhost ~]# fdisk -l |tail\n WARNING: fdisk GPT support is currently new, and therefore in an experimental phase. Use at your own discretion.\n\n Disk /dev/sdc: 21.5 GB, 21474836480 bytes, 41943040 sectors\n Units = sectors of 1 * 512 = 512 bytes\n Sector size (logical/physical): 512 bytes / 512 bytes\n I/O size (minimum/optimal): 512 bytes / 512 bytes\n Disk label type: gpt\n Disk identifier: FFA53173-E89A-471F-8BDA-3901C3CF4D66\n #         Start          End    Size  Type            Name\n")])])])]),e._v(" "),n("li",[n("p",[e._v("执行命令"),n("code",[e._v("mkfs.ext3 /dev/sdc")]),e._v("格式化磁盘")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# mkfs.ext3 /dev/sdc \n mke2fs 1.42.9 (28-Dec-2013)\n /dev/sdc is entire device, not just one partition!\n Proceed anyway? (y,n) y\n Filesystem label=\n OS type: Linux\n Block size=4096 (log=2)\n Fragment size=4096 (log=2)\n Stride=0 blocks, Stripe width=0 blocks\n 1310720 inodes, 5242880 blocks\n 262144 blocks (5.00%) reserved for the super user\n First data block=0\n Maximum filesystem blocks=4294967296\n 160 block groups\n 32768 blocks per group, 32768 fragments per group\n 8192 inodes per group\n Superblock backups stored on blocks: \n         32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, \n         4096000\n\n Allocating group tables: done                            \n Writing inode tables: done                            \n Creating journal (32768 blocks): done\n Writing superblocks and filesystem accounting information: done\n")])])])]),e._v(" "),n("li",[n("p",[e._v("parted命令也可以分区，依次命令执行如下"),n("code",[e._v("parted -> select /dev/sdc -> mklabel gpt -> mkpart primary 0 -1 -> print -> quit")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# parted \n GNU Parted 3.1\n Using /dev/sda\n Welcome to GNU Parted! Type 'help' to view a list of commands.\n (parted) select /dev/sdc \n Using /dev/sdc\n (parted) mklabel gpt    #格式类型为GPT                                                     \n Warning: The existing disk label on /dev/sdc will be destroyed and all data on this disk will be lost. Do you want to continue?\n Yes/No? yes                                                               \n (parted) mkpart primary 0 -1    #将整块硬盘分为一个分区\n Warning: The resulting partition is not properly aligned for best performance.\n Ignore/Cancel? Ignore                                                     \n (parted) print    #打印我们刚分区的磁盘信息         \n Model: VMware, VMware Virtual S (scsi)\n Disk /dev/sdc: 21.5GB\n Sector size (logical/physical): 512B/512B\n Partition Table: gpt\n Disk Flags: \n\n Number  Start   End     Size    File system  Name     Flags\n 1      17.4kB  21.5GB  21.5GB               primary\n (parted) quit    # 退出                                                     \n Information: You may need to update /etc/fstab.\n")])])])]),e._v(" "),n("li",[n("p",[e._v("/dev/sdc1分区格式化，使用mount命令挂载/data/目录，并将挂载分区命令写入/etc/fstab文件中，开机启动")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" [root@localhost ~]# mkfs.ext3 /dev/sdc1 \n mke2fs 1.42.9 (28-Dec-2013)\n Filesystem label=\n OS type: Linux\n Block size=4096 (log=2)\n Fragment size=4096 (log=2)\n Stride=0 blocks, Stripe width=0 blocks\n 1310720 inodes, 5242631 blocks\n 262131 blocks (5.00%) reserved for the super user\n First data block=0\n Maximum filesystem blocks=4294967296\n 160 block groups\n 32768 blocks per group, 32768 fragments per group\n 8192 inodes per group\n Superblock backups stored on blocks: \n         32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, \n         4096000\n\n Allocating group tables: done                            \n Writing inode tables: done                            \n Creating journal (32768 blocks): done\n Writing superblocks and filesystem accounting information: done   \n\n # 挂载/dev/sdb1 分区至/data/目录\n [root@localhost ~]# mount /dev/sdb1  /data/\n\n  #`df -h`查看挂载是否成功\n [root@localhost ~]# df -h\n Filesystem               Size  Used Avail Use% Mounted on\n /dev/mapper/centos-root   36G  1.5G   35G   4% /\n devtmpfs                 735M     0  735M   0% /dev\n tmpfs                    747M     0  747M   0% /dev/shm\n tmpfs                    747M  9.5M  737M   2% /run\n tmpfs                    747M     0  747M   0% /sys/fs/cgroup\n /dev/sda1               1014M  130M  885M  13% /boot\n tmpfs                    150M     0  150M   0% /run/user/0\n /dev/sdc1                9.8G   37M  9.2G   1% /data\n")])])])])]),e._v(" "),n("h2",{attrs:{id:"mount命令工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mount命令工具"}},[e._v("#")]),e._v(" mount命令工具")]),e._v(" "),n("p",[e._v("Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。")]),e._v(" "),n("h3",{attrs:{id:"mount命令参数详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mount命令参数详解"}},[e._v("#")]),e._v(" mount命令参数详解")]),e._v(" "),n("p",[n("strong",[e._v("语法")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    mount [-hV]\n    mount -a [-fFnrsvw] [-t vfstype]\n    mount [-fnrsvw] [-o options [,...]] device | dir\n    mount [-fnrsvw] [-t vfstype] [-o options] device dir\n")])])]),n("p",[n("strong",[e._v("参数如下：")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('-V：显示mount工具版本号；\n-l：显示已加载的文件系统列表；\n-h：显示帮助信息并退出；\n-v：冗长模式，输出指令执行的详细信息；\n-n：加载没有写入文件"/etc/mtab"中的文件系统；\n-r：将文件系统加载为只读模式；\n-a：加载文件"/etc/fstab"中描述的所有文件系统。\n-o options：(挂载文件系统的选项),常见扩展指令rw，remount，loop等;\n    其中与-o相关指令如下：\n    -o atime：系统会在每次读取文档时更新文档时间。\n    -o noatime：系统会在每次读取档案时不更新文档时间『上一次调用时间』。\n    -o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async等\n    -o exec:允许执行档被执行\n    -o user、-o nouser：使用者可以执行 mount/umount 的动作。\n    -o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。\n    -o ro：用唯读模式挂上。\n    -o rw：用可读写模式挂上。\n    -o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。\n-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。\n    其中与-t相关指令如下：\n    iso9660:光盘或光盘镜像。\n    msdos：Fat16文件系统。（微软磁盘操作系统）\n    vfat:Fat32文件系统。（即虚拟文件分配表）\n    ntfs：ntfs文件系统。\n    ntfs-3g：识别移动硬盘格式。\n    smbfs：挂载Windows文件系统网络。\n    nfs：UNIX/Linux 文件系统网络。\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br"),n("span",{staticClass:"line-number"},[e._v("22")]),n("br"),n("span",{staticClass:"line-number"},[e._v("23")]),n("br"),n("span",{staticClass:"line-number"},[e._v("24")]),n("br"),n("span",{staticClass:"line-number"},[e._v("25")]),n("br"),n("span",{staticClass:"line-number"},[e._v("26")]),n("br"),n("span",{staticClass:"line-number"},[e._v("27")]),n("br")])]),n("h3",{attrs:{id:"常用的mount案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用的mount案例"}},[e._v("#")]),e._v(" 常用的mount案例")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    mount /dev/sdb1 /data   # /dev/sdb1分区挂载至/data目录\n    mount /dev/cdrom /mnt/  # 将/dev/cdrom光盘挂载至/mnt目录\n    mount -t ntfs-3g /dev/sdc /data1 # 将/dev/sdc移动硬盘挂载至/data1目录\n    mount -o remount,rw /   # 重新以读写模式挂载/系统\n    mount -t iso9660 -o loop centos7.iso /mnt  # 将CentOS7.iso镜像文件挂载至/mnt目录\n    mount -t fat32 /dev/sdd1 /mnt        # 将U盘/dev/sdd1挂载至/mnt目录\n    mount -t nfs 192.168.1.11:/data /mnt # 将远程192.18.1.11:/data目录挂载至本地mnt目录\n")])])]),n("h2",{attrs:{id:"linux硬盘故障修复"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linux硬盘故障修复"}},[e._v("#")]),e._v(" Linux硬盘故障修复")]),e._v(" "),n("p",[e._v("企业服务器经常会发现系统的分区变成只读文件系统，错误提示信息为Read-Only file system。出现只读文件系统会导致只能读取而无法写入新文件、新数据等操作。")]),e._v(" "),n("p",[e._v("造成该原因包括：磁盘老旧长时间大量读写、文件系统文件被破坏、磁盘碎片文件、异常断电、读写中断等。")]),e._v(" "),n("p",[e._v("以企业CentOS 7 linux 为案例来修复文件系统，步骤如下：")]),e._v(" "),n("p",[e._v("（1）、远程备份本地其他重要数据，出现只读文件系统，需要先备份其他重要数据，基于rsync|scp远程备份，其中/data为源目录，/data/backup/2018/为目标备份目录。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    rsync -av /data root@192.168.111.188:/data/backup/2018/\n")])])]),n("p",[e._v("（2）、可以重新挂载/文件，挂在命令如下，测试文件系统是否可以写入文件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    mount -a remount,rw /\n")])])]),n("p",[e._v("（3）、如果系统重新挂载/系统还是无法解决问题，则需重启服务器以CD/DVD光盘引导进入Linux Rescue修复模式。")]),e._v(" "),n("h2",{attrs:{id:"思考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[e._v("#")]),e._v(" 思考"),n("Badge",{attrs:{text:"本章小结",type:"warn"}})],1),e._v(" "),n("h3",{attrs:{id:"当linux启动时卡住mysql服务时"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#当linux启动时卡住mysql服务时"}},[e._v("#")]),e._v(" 当linux启动时卡住mysql服务时")]),e._v(" "),n("p",[e._v("我们在Linux环境下安装完mysql之后，一般会把mysql添加到系统自动启动列表中，修改方法是：\n在/etc/rc.local文件中添加/usr/local/mysql/bin/mysqld_safe --user=mysql &\n这样通常为用户带来了很多方便，但是笔者的Linux系统突然有一天启动时被启动mysql服务卡住了，于是我在网上找了一些解决方案，分述如下：")]),e._v(" "),n("ol",[n("li",[e._v("一般在mysql服务启动之前，ssh服务已经启动，所以可以使用putty等客户端工具登录Linux系统，修改/etc/rc.local文件（或者使用chkconfig --del mysqld命令），把mysql相关的服务删除，然后再重新启动。")]),e._v(" "),n("li",[e._v("在登录Linux系统后，使用命令ps aux | grep mysql 命令将mysql相关的服务搜出来，然后kill掉对应的进程号，这样Linux系统可以继续启动")])])])}),[],!1,null,null,null);s.default=a.exports}}]);