(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{404:function(_,v,t){"use strict";t.r(v);var o=t(43),s=Object(o.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[_._v("#")]),_._v(" 继承")]),_._v(" "),t("h2",[_._v("目标")]),_._v(" "),t("ul",[t("li",[_._v("单继承")]),_._v(" "),t("li",[_._v("多继承")])]),_._v(" "),t("p",[t("strong",[_._v("面向对象三大特性")])]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("封装")]),_._v(" 根据 "),t("strong",[_._v("职责")]),_._v(" 将 "),t("strong",[_._v("属性")]),_._v(" 和 "),t("strong",[_._v("方法")]),_._v(" "),t("strong",[_._v("封装")]),_._v(" 到一个抽象的 "),t("strong",[_._v("类")]),_._v(" 中")]),_._v(" "),t("li",[t("strong",[_._v("继承")]),_._v(" "),t("strong",[_._v("实现代码的重用")]),_._v("，相同的代码不需要重复的编写")]),_._v(" "),t("li",[t("strong",[_._v("多态")]),_._v(" 不同的对象调用相同的方法，产生不同的执行结果，"),t("strong",[_._v("增加代码的灵活度")])])]),_._v(" "),t("h2",{attrs:{id:"toc_2"}},[_._v("01. 单继承")]),_._v(" "),t("h3",{attrs:{id:"toc_3"}},[_._v("1.1 继承的概念、语法和特点")]),_._v(" "),t("p",[t("strong",[_._v("继承的概念")]),_._v("："),t("strong",[_._v("子类")]),_._v(" 拥有 "),t("strong",[_._v("父类")]),_._v(" 的所有 "),t("strong",[_._v("方法")]),_._v(" 和 "),t("strong",[_._v("属性")])]),_._v(" "),t("p",[_._v("<"),t("img",{attrs:{src:_.$withBase("/media/15006307099794/011_%E7%BB%A7%E6%89%BF%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA.png"),alt:"011_继承对比图示"}}),_._v("￼")]),_._v(" "),t("h4",{attrs:{id:"toc_4"}},[_._v("1) 继承的语法")]),_._v(" "),t("pre",[t("code",{staticClass:"language-python"},[_._v("class 类名(父类名):\n\n    pass\n")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("子类")]),_._v(" 继承自 "),t("strong",[_._v("父类")]),_._v("，可以直接 "),t("strong",[_._v("享受")]),_._v(" 父类中已经封装好的方法，不需要再次开发")]),_._v(" "),t("li",[t("strong",[_._v("子类")]),_._v(" 中应该根据 "),t("strong",[_._v("职责")]),_._v("，封装 "),t("strong",[_._v("子类特有的")]),_._v(" "),t("strong",[_._v("属性和方法")])])]),_._v(" "),t("h4",{attrs:{id:"toc_5"}},[_._v("2) 专业术语")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("Dog")]),_._v(" 类是 "),t("code",[_._v("Animal")]),_._v(" 类的"),t("strong",[_._v("子类")]),_._v("，"),t("code",[_._v("Animal")]),_._v(" 类是 "),t("code",[_._v("Dog")]),_._v(" 类的"),t("strong",[_._v("父类")]),_._v("，"),t("code",[_._v("Dog")]),_._v(" 类从 "),t("code",[_._v("Animal")]),_._v(" 类"),t("strong",[_._v("继承")])]),_._v(" "),t("li",[t("code",[_._v("Dog")]),_._v(" 类是 "),t("code",[_._v("Animal")]),_._v(" 类的"),t("strong",[_._v("派生类")]),_._v("，"),t("code",[_._v("Animal")]),_._v(" 类是 "),t("code",[_._v("Dog")]),_._v(" 类的"),t("strong",[_._v("基类")]),_._v("，"),t("code",[_._v("Dog")]),_._v(" 类从 "),t("code",[_._v("Animal")]),_._v(" 类"),t("strong",[_._v("派生")])])]),_._v(" "),t("h4",{attrs:{id:"toc_6"}},[_._v("3) 继承的传递性")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("C")]),_._v(" 类从 "),t("code",[_._v("B")]),_._v(" 类继承，"),t("code",[_._v("B")]),_._v(" 类又从 "),t("code",[_._v("A")]),_._v(" 类继承")]),_._v(" "),t("li",[_._v("那么 "),t("code",[_._v("C")]),_._v(" 类就具有 "),t("code",[_._v("B")]),_._v(" 类和 "),t("code",[_._v("A")]),_._v(" 类的所有属性和方法")])]),_._v(" "),t("p",[t("strong",[_._v("子类")]),_._v(" 拥有 "),t("strong",[_._v("父类")]),_._v(" 以及 "),t("strong",[_._v("父类的父类")]),_._v(" 中封装的所有 "),t("strong",[_._v("属性")]),_._v(" 和 "),t("strong",[_._v("方法")])]),_._v(" "),t("p",[t("strong",[_._v("提问")])]),_._v(" "),t("p",[t("strong",[_._v("哮天犬")]),_._v(" 能够调用 "),t("code",[_._v("Cat")]),_._v(" 类中定义的 "),t("code",[_._v("catch")]),_._v(" 方法吗？")]),_._v(" "),t("p",[t("strong",[_._v("答案")])]),_._v(" "),t("p",[t("strong",[_._v("不能")]),_._v("，因为 "),t("strong",[_._v("哮天犬")]),_._v(" 和 "),t("code",[_._v("Cat")]),_._v(" 之间没有 "),t("strong",[_._v("继承")]),_._v(" 关系")]),_._v(" "),t("h3",{attrs:{id:"toc_7"}},[_._v("1.2 方法的重写")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("子类")]),_._v(" 拥有 "),t("strong",[_._v("父类")]),_._v(" 的所有 "),t("strong",[_._v("方法")]),_._v(" 和 "),t("strong",[_._v("属性")])]),_._v(" "),t("li",[t("strong",[_._v("子类")]),_._v(" 继承自 "),t("strong",[_._v("父类")]),_._v("，可以直接 "),t("strong",[_._v("享受")]),_._v(" 父类中已经封装好的方法，不需要再次开发")])]),_._v(" "),t("p",[t("strong",[_._v("应用场景")])]),_._v(" "),t("ul",[t("li",[_._v("当 "),t("strong",[_._v("父类")]),_._v(" 的方法实现不能满足子类需求时，可以对方法进行 "),t("strong",[_._v("重写(override)")])])]),_._v(" "),t("p",[_._v("<"),t("img",{staticStyle:{width:"203px"},attrs:{src:_.$withBase("/media/15006307099794/012_%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99.png"),alt:"012_继承方法的重写"}}),_._v("￼")]),_._v(" "),t("p",[t("strong",[_._v("重写")]),_._v(" 父类方法有两种情况：")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("覆盖")]),_._v(" 父类的方法")]),_._v(" "),t("li",[_._v("对父类方法进行 "),t("strong",[_._v("扩展")])])]),_._v(" "),t("h4",{attrs:{id:"toc_8"}},[_._v("1) 覆盖父类的方法")]),_._v(" "),t("ul",[t("li",[_._v("如果在开发中，"),t("strong",[_._v("父类的方法实现")]),_._v(" 和 "),t("strong",[_._v("子类的方法实现")]),_._v("，"),t("strong",[_._v("完全不同")])]),_._v(" "),t("li",[_._v("就可以使用 "),t("strong",[_._v("覆盖")]),_._v(" 的方式，"),t("strong",[_._v("在子类中")]),_._v(" "),t("strong",[_._v("重新编写")]),_._v(" 父类的方法实现")])]),_._v(" "),t("blockquote",[t("p",[_._v("具体的实现方式，就相当于在 "),t("strong",[_._v("子类中")]),_._v(" 定义了一个 "),t("strong",[_._v("和父类同名的方法并且实现")])])]),_._v(" "),t("p",[_._v("重写之后，在运行时，"),t("strong",[_._v("只会调用")]),_._v(" 子类中重写的方法，而不再会调用 "),t("strong",[_._v("父类封装的方法")])]),_._v(" "),t("h4",{attrs:{id:"toc_9"}},[_._v("2) 对父类方法进行 "),t("strong",[_._v("扩展")])]),_._v(" "),t("ul",[t("li",[_._v("如果在开发中，"),t("strong",[_._v("子类的方法实现")]),_._v(" 中 "),t("strong",[_._v("包含")]),_._v(" "),t("strong",[_._v("父类的方法实现")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("父类原本封装的方法实现")]),_._v(" 是 "),t("strong",[_._v("子类方法的一部分")])])])]),_._v(" "),t("li",[_._v("就可以使用 "),t("strong",[_._v("扩展")]),_._v(" 的方式\n"),t("ol",[t("li",[t("strong",[_._v("在子类中")]),_._v(" "),t("strong",[_._v("重写")]),_._v(" 父类的方法")]),_._v(" "),t("li",[_._v("在需要的位置使用 "),t("code",[_._v("super().父类方法")]),_._v(" 来调用父类方法的执行")]),_._v(" "),t("li",[_._v("代码其他的位置针对子类的需求，编写 "),t("strong",[_._v("子类特有的代码实现")])])])])]),_._v(" "),t("h5",{attrs:{id:"toc_10"}},[_._v("关于 "),t("code",[_._v("super")])]),_._v(" "),t("ul",[t("li",[_._v("在 "),t("code",[_._v("Python")]),_._v(" 中 "),t("code",[_._v("super")]),_._v(" 是一个 "),t("strong",[_._v("特殊的类")])]),_._v(" "),t("li",[t("code",[_._v("super()")]),_._v(" 就是使用 "),t("code",[_._v("super")]),_._v(" 类创建出来的对象")]),_._v(" "),t("li",[t("strong",[_._v("最常")]),_._v(" 使用的场景就是在 "),t("strong",[_._v("重写父类方法时")]),_._v("，调用 "),t("strong",[_._v("在父类中封装的方法实现")])])]),_._v(" "),t("h5",{attrs:{id:"toc_11"}},[_._v("调用父类方法的另外一种方式（知道）")]),_._v(" "),t("blockquote",[t("p",[_._v("在 "),t("code",[_._v("Python 2.x")]),_._v(" 时，如果需要调用父类的方法，还可以使用以下方式：")])]),_._v(" "),t("pre",[t("code",{staticClass:"language-python"},[_._v("父类名.方法(self)\n")])]),_._v(" "),t("ul",[t("li",[_._v("这种方式，目前在 "),t("code",[_._v("Python 3.x")]),_._v(" 还支持这种方式")]),_._v(" "),t("li",[_._v("这种方法 "),t("strong",[_._v("不推荐使用")]),_._v("，因为一旦 "),t("strong",[_._v("父类发生变化")]),_._v("，方法调用位置的 "),t("strong",[_._v("类名")]),_._v(" 同样需要修改")])]),_._v(" "),t("p",[t("strong",[_._v("提示")])]),_._v(" "),t("ul",[t("li",[_._v("在开发时，"),t("code",[_._v("父类名")]),_._v(" 和 "),t("code",[_._v("super()")]),_._v(" 两种方式不要混用")]),_._v(" "),t("li",[_._v("如果使用 "),t("strong",[_._v("当前子类名")]),_._v(" 调用方法，会形成递归调用，"),t("strong",[_._v("出现死循环")])])]),_._v(" "),t("h3",{attrs:{id:"toc_12"}},[_._v("1.3 父类的 私有属性 和 私有方法")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("子类对象")]),_._v(" "),t("strong",[_._v("不能")]),_._v(" 在自己的方法内部，"),t("strong",[_._v("直接")]),_._v(" 访问 父类的 "),t("strong",[_._v("私有属性")]),_._v(" 或 "),t("strong",[_._v("私有方法")])]),_._v(" "),t("li",[t("strong",[_._v("子类对象")]),_._v(" 可以通过 "),t("strong",[_._v("父类")]),_._v(" 的 "),t("strong",[_._v("公有方法")]),_._v(" "),t("strong",[_._v("间接")]),_._v(" 访问到 "),t("strong",[_._v("私有属性")]),_._v(" 或 "),t("strong",[_._v("私有方法")])])]),_._v(" "),t("blockquote",[t("ul",[t("li",[t("strong",[_._v("私有属性、方法")]),_._v(" 是对象的隐私，不对外公开，"),t("strong",[_._v("外界")]),_._v(" 以及 "),t("strong",[_._v("子类")]),_._v(" 都不能直接访问")]),_._v(" "),t("li",[t("strong",[_._v("私有属性、方法")]),_._v(" 通常用于做一些内部的事情")])])]),_._v(" "),t("p",[t("strong",[_._v("示例")])]),_._v(" "),t("p",[_._v("<"),t("img",{staticStyle:{width:"220px"},attrs:{src:_.$withBase("/media/15006307099794/013_%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.png"),alt:"013_父类的私有属性和私有方法"}}),_._v("￼")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("B")]),_._v(" 的对象不能直接访问 "),t("code",[_._v("__num2")]),_._v(" 属性")]),_._v(" "),t("li",[t("code",[_._v("B")]),_._v(" 的对象不能在 "),t("code",[_._v("demo")]),_._v(" 方法内访问 "),t("code",[_._v("__num2")]),_._v(" 属性")]),_._v(" "),t("li",[t("code",[_._v("B")]),_._v(" 的对象可以在 "),t("code",[_._v("demo")]),_._v(" 方法内，调用父类的 "),t("code",[_._v("test")]),_._v(" 方法")]),_._v(" "),t("li",[_._v("父类的 "),t("code",[_._v("test")]),_._v(" 方法内部，能够访问 "),t("code",[_._v("__num2")]),_._v(" 属性和 "),t("code",[_._v("__test")]),_._v(" 方法")])]),_._v(" "),t("h2",{attrs:{id:"toc_13"}},[_._v("02. 多继承")]),_._v(" "),t("p",[t("strong",[_._v("概念")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("子类")]),_._v(" 可以拥有 "),t("strong",[_._v("多个父类")]),_._v("，并且具有 "),t("strong",[_._v("所有父类")]),_._v(" 的 "),t("strong",[_._v("属性")]),_._v(" 和 "),t("strong",[_._v("方法")])]),_._v(" "),t("li",[_._v("例如："),t("strong",[_._v("孩子")]),_._v(" 会继承自己 "),t("strong",[_._v("父亲")]),_._v(" 和 "),t("strong",[_._v("母亲")]),_._v(" 的 "),t("strong",[_._v("特性")])])]),_._v(" "),t("p",[_._v("<"),t("img",{staticStyle:{width:"384px"},attrs:{src:_.$withBase("/media/15006307099794/014_%E5%A4%9A%E7%BB%A7%E6%89%BF.png"),alt:"014_多继承"}}),_._v("￼")]),_._v(" "),t("p",[t("strong",[_._v("语法")])]),_._v(" "),t("pre",[t("code",{staticClass:"language-python"},[_._v("class 子类名(父类名1, 父类名2...)\n    pass\n")])]),_._v(" "),t("h3",{attrs:{id:"toc_14"}},[_._v("2.1 多继承的使用注意事项")]),_._v(" "),t("p",[t("strong",[_._v("问题的提出")])]),_._v(" "),t("ul",[t("li",[_._v("如果 "),t("strong",[_._v("不同的父类")]),_._v(" 中存在 "),t("strong",[_._v("同名的方法")]),_._v("，"),t("strong",[_._v("子类对象")]),_._v(" 在调用方法时，会调用 "),t("strong",[_._v("哪一个父类中")]),_._v("的方法呢？")])]),_._v(" "),t("blockquote",[t("p",[_._v("提示："),t("strong",[_._v("开发时，应该尽量避免这种容易产生混淆的情况！")]),_._v(" —— 如果 "),t("strong",[_._v("父类之间")]),_._v(" 存在 "),t("strong",[_._v("同名的属性或者方法")]),_._v("，应该 "),t("strong",[_._v("尽量避免")]),_._v(" 使用多继承")])]),_._v(" "),t("p",[_._v("<"),t("img",{staticStyle:{width:"384px"},attrs:{src:_.$withBase("/media/15006307099794/015_%E5%A4%9A%E7%BB%A7%E6%89%BFII.png"),alt:"015_多继承II"}}),_._v("￼")]),_._v(" "),t("h4",{attrs:{id:"toc_15"}},[_._v("Python 中的 MRO —— 方法搜索顺序（知道）")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("Python")]),_._v(" 中针对 "),t("strong",[_._v("类")]),_._v(" 提供了一个 "),t("strong",[_._v("内置属性")]),_._v(" "),t("code",[_._v("__mro__")]),_._v(" 可以查看 "),t("strong",[_._v("方法")]),_._v(" 搜索顺序")]),_._v(" "),t("li",[_._v("MRO 是 "),t("code",[_._v("method resolution order")]),_._v("，主要用于 "),t("strong",[_._v("在多继承时判断 方法、属性 的调用 路径")])])]),_._v(" "),t("pre",[t("code",{staticClass:"language-python"},[_._v("print(C.__mro__)\n")])]),_._v(" "),t("p",[t("strong",[_._v("输出结果")])]),_._v(" "),t("pre",[t("code",[_._v("(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)\n")])]),_._v(" "),t("ul",[t("li",[_._v("在搜索方法时，是按照 "),t("code",[_._v("__mro__")]),_._v(" 的输出结果 "),t("strong",[_._v("从左至右")]),_._v(" 的顺序查找的")]),_._v(" "),t("li",[_._v("如果在当前类中 "),t("strong",[_._v("找到方法，就直接执行，不再搜索")])]),_._v(" "),t("li",[_._v("如果 "),t("strong",[_._v("没有找到，就查找下一个类")]),_._v(" 中是否有对应的方法，"),t("strong",[_._v("如果找到，就直接执行，不再搜索")])]),_._v(" "),t("li",[_._v("如果找到最后一个类，还没有找到方法，程序报错")])]),_._v(" "),t("h3",{attrs:{id:"toc_16"}},[_._v("2.2 新式类与旧式（经典）类")]),_._v(" "),t("blockquote",[t("p",[t("code",[_._v("object")]),_._v(" 是 "),t("code",[_._v("Python")]),_._v(" 为所有对象提供的 "),t("strong",[_._v("基类")]),_._v("，提供有一些内置的属性和方法，可以使用 "),t("code",[_._v("dir")]),_._v(" 函数查看")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("新式类")]),_._v("：以 "),t("code",[_._v("object")]),_._v(" 为基类的类，"),t("strong",[_._v("推荐使用")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("经典类")]),_._v("：不以 "),t("code",[_._v("object")]),_._v(" 为基类的类，"),t("strong",[_._v("不推荐使用")])])]),_._v(" "),t("li",[t("p",[_._v("在 "),t("code",[_._v("Python 3.x")]),_._v(" 中定义类时，如果没有指定父类，会 "),t("strong",[_._v("默认使用")]),_._v(" "),t("code",[_._v("object")]),_._v(" 作为该类的 "),t("strong",[_._v("基类")]),_._v(" —— "),t("code",[_._v("Python 3.x")]),_._v(" 中定义的类都是 "),t("strong",[_._v("新式类")])])]),_._v(" "),t("li",[t("p",[_._v("在 "),t("code",[_._v("Python 2.x")]),_._v(" 中定义类时，如果没有指定父类，则不会以 "),t("code",[_._v("object")]),_._v(" 作为 "),t("strong",[_._v("基类")])])])]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("新式类")]),_._v(" 和 "),t("strong",[_._v("经典类")]),_._v(" 在多继承时 —— "),t("strong",[_._v("会影响到方法的搜索顺序")])])]),_._v(" "),t("p",[_._v("为了保证编写的代码能够同时在 "),t("code",[_._v("Python 2.x")]),_._v(" 和 "),t("code",[_._v("Python 3.x")]),_._v(" 运行！"),t("br"),_._v("\n今后在定义类时，"),t("strong",[_._v("如果没有父类，建议统一继承自 "),t("code",[_._v("object")])])]),_._v(" "),t("pre",[t("code",{staticClass:"language-python"},[_._v("class 类名(object):\n    pass\n")])])])}),[],!1,null,null,null);v.default=s.exports}}]);