(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{363:function(t,e,r){"use strict";r.r(e);var n=r(43),_=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"http协议详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http协议详解"}},[t._v("#")]),t._v(" HTTP协议详解")]),t._v(" "),r("p",[t._v("超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。")]),t._v(" "),r("h2",{attrs:{id:"tcp协议与http协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议与http协议"}},[t._v("#")]),t._v(" TCP协议与HTTP协议")]),t._v(" "),r("p",[t._v("1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。")]),t._v(" "),r("p",[t._v("从应用领域来说TCP协议主要用户数据传输控制，而HTTP协议主要用于应用层面的数据交互，本质上两者没有可比性。")]),t._v(" "),r("p",[t._v("HTTP协议属于应用层协议，是建立在TCP协议基础之上的，HTTP协议以客户端请求和服务器端应答为标准，浏览器通常称为客户端，而WEB服务器称为服务器端。客户端打开任意一个端口向服务器指定的端口（默认80）发起HTTP请求，首先会发起TCP三次握手，TCP三次握手的目的是建立可靠的数据连接通道，TCP三次握手通道建立完毕，进行HTTP数据交互。")]),t._v(" "),r("p",[t._v("当客户端请求的数据接收完毕后，HTTP服务器端会断开TCP连接，整个HTTP连接过程非常短，HTTP连接也成为无状态的连接，无状态连接是指客户端每次向服务器HTTP请求时，每次请求都会建立一个新的HTTP连接，而不是在一个HTTP请求基础之上进行所有数据的交互。")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("HTTP与TCP关系结构图")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("HTTP"),r("br"),t._v("SSL/TLS")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("TCP")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("IP")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("数据链路层")])])])]),t._v(" "),r("h2",{attrs:{id:"资源定位标识符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源定位标识符"}},[t._v("#")]),t._v(" 资源定位标识符")]),t._v(" "),r("p",[t._v("HTTP请求的内容资源由统一资源标识符（uniform resource identifier，URI）来表示，关于资源定位及标识符有三种：URI、URN、URL三种资源定位。")]),t._v(" "),r("p",[t._v("统一资源标志符（Uniform Resource Identifier，URI）用来唯一的标识一个资源。")]),t._v(" "),r("p",[t._v("统一资源定位符（Uniform Resource Locator，URL）是一种具体的URI，URL可以用来表示一个资源，而且可以访问或者获取该资源")]),t._v(" "),r("p",[t._v("统一资源命名（Uniform Resource Name，URN）即通过名字来表示资源的。")]),t._v(" "),r("img",{attrs:{src:t.$withBase("/http/url_uri_urn.png"),alt:"url_uri_urn"}}),t._v(" "),r("p",[t._v("三种资源标识，其中URL资源标识方式使用最为广泛，完整的URL标识格式如下")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("protocol://host[:port]/path/.../[?query-string][#anchor]\n\n参数详解：\n协议为(protocol)：http、https、ftp、rsync等；\n主机为(host:port)：服务器IP地址或者域名；\n端口号为(port):服务器端口号，HTTP协议默认的端口号为80，https协议默认的端口号为443，默认的可以省略；\n文件路径为(path)：访问资源在服务器的路径；\n请求参数(query-string)：传递给服务器的参数及字符串；\n定位位置(anchor)：锚定结束；\n\n举例：\nhttps://www.zhangqifei.top/book/index.html?id=2#111\n\n对应关系：\n协议为(protocol)：https\n主机为(host:port)：www.zhangqifei.top\n端口号为(port):443\n文件路径为(path)：book/index.html\n请求参数(query-string)：id=2\n定位位置(anchor)：#111\n")])])]),r("h2",{attrs:{id:"http与端口通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http与端口通信"}},[t._v("#")]),t._v(" HTTP与端口通信")]),t._v(" "),r("p",[t._v("HTTP Web服务器默认在本机会监听80端口，不仅HTTP会开启监听端口，其实每个软件程序在Linux系统中运行，会以进程的方式启动，程序就会启动并监听本地接口的端口,那么为什么会引人端口这个概念呢?")]),t._v(" "),r("p",[t._v("端口是TCP/IP协议中应用层进程与传输层协议实体间的通信接口，端口是操作系统可分配的一种资源，应用程序通过系统调用与某个端口绑定后,传输层传给该端口的数据会被该进程接收.相应进程发给传输层的数据都通过该端口输出。")]),t._v(" "),r("p",[t._v("在网络通信过程中，需要唯一识别通信两端设备的端点，就是使用端口识别运行于某主机中的应用程序。如果没有引人端口，则只能通过PID进程号进行识别，而PID进程号是系统动态分配的,不同的系统会使用不同的进程标识符，应用程序在运行之前没有明确的进程号，如果需要运行后再广播进程号则很难保证通信的顺利进行。")]),t._v(" "),r("p",[t._v("而引人端口后，就可以利用端口号识别应用程序，同时通过固定端口号来识别和使用某些公共服务，例如HTTP默认使用80端口，而FTP使用21、20端口,MySQL则使用3306端口。")]),t._v(" "),r("p",[t._v("使用端口还有一个原因就是随着计算机网络技术的发展，物理机器上的硬件接口已不能满足网络通信的要求，而TCP/IP协议模型作为网络通信的标准就解决了这个通信难题。")]),t._v(" "),r("p",[t._v("TCP/IP协议中引人了一种被称为套接字(socket)的应用程序接口。基于socket 接口技术，一台计算机就可以与任何一台具有socket接口的计算机进行通信，而监听的端口在服务器端也称之为socket接口。")]),t._v(" "),r("h2",{attrs:{id:"http-request与response详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-request与response详解"}},[t._v("#")]),t._v(" HTTP request与response详解")]),t._v(" "),r("p",[t._v("客户端浏览器向Web服务器发起request, Web服务器接到request后进行处理，会生成相应的response信息返给浏览器，客户端浏览器收到服务器返回的response 信息，会对信息进行解析处理,最终用户看到浏览器展示Web服务器的网页内容。")]),t._v(" "),r("p",[t._v("客户端发起request,request消息分为3个部分，分别包括request line、request header、body。")]),t._v(" "),r("p",[t._v("UNIX/Linux系统中执行"),r("code",[t._v("curl -v")]),t._v("命令可以打印访问WEB服务器的request、response详细处理流程。")]),t._v(" "),r("img",{attrs:{src:t.$withBase("/http/request.png"),alt:"request"}}),t._v(" "),r("p",[t._v("HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：")]),t._v(" "),r("ol",[r("li",[t._v("HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。")]),t._v(" "),r("li",[t._v("GET：向特定的资源发出请求。")]),t._v(" "),r("li",[t._v("POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。")]),t._v(" "),r("li",[t._v("PUT：向指定资源位置上传其最新内容。")]),t._v(" "),r("li",[t._v("DELETE：请求服务器删除Request-URI所标识的资源。")]),t._v(" "),r("li",[t._v("TRACE：回显服务器收到的请求，主要用于测试或诊断。")]),t._v(" "),r("li",[t._v("CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。")]),t._v(" "),r("li",[t._v("OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。")])]),t._v(" "),r("p",[t._v("虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。")]),t._v(" "),r("p",[r("a",{attrs:{href:"http://www.cnblogs.com/lancidie/p/8251187.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考：request和response解析"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://www.cnblogs.com/liangxiaofeng/p/5798607.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考：HTTP协议的8种请求类型介绍"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"http-1-0-1-1协议区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-1-1协议区别"}},[t._v("#")]),t._v(" HTTP 1.0/1.1协议区别")]),t._v(" "),r("p",[t._v("HTTP1.0，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个对象，严重影响客户机和服务器的性能。")]),t._v(" "),r("p",[t._v("HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。")]),t._v(" "),r("p",[t._v("HTTP 1.1 还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0 的功能。")]),t._v(" "),r("p",[t._v("在HTTP 1.1中增加Host请求头字段后，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。")]),t._v(" "),r("p",[t._v("HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。")]),t._v(" "),r("p",[t._v("HTTP1.1还有身份认证机制，许多web站点要求用户提供一个用户名—口令对才能访问存放在其服务器中的文档，这种要求称为身份认证(authentication)。HTTP提供特殊的状态码和头部来帮助Web站点执行身份认证。")]),t._v(" "),r("p",[t._v("HTTP/1.1支持文件断点续传，RANGE:bytes，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。RANGE:bytes=XXXX表示要求服务器从文件XXXX字节处开始传送，断点续传。")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/zhengshiqiang47/p/8673559.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考：HTTP协议以及HTTP2.0/1.1/1.0区别"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"http状态码详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http状态码详解"}},[t._v("#")]),t._v(" HTTP状态码详解")]),t._v(" "),r("p",[r("strong",[t._v("状态代码：")])]),t._v(" "),r("p",[t._v("状态代码由3位数字组成，表示请求是否被理解或被满足。")]),t._v(" "),r("p",[r("strong",[t._v("状态描述：")])]),t._v(" "),r("p",[t._v("状态描述给出了关于状态代码的简短的文字描述。")]),t._v(" "),r("p",[t._v("状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。")]),t._v(" "),r("p",[r("strong",[t._v("第一个数字有五种可能的取值：")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("分类")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("分类描述")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("1**")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("信息，服务器收到请求，需要请求者继续执行操作")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("2**")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("成功，操作被成功接收并处理")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("3**")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("重定向，需要进一步的操作以完成请求")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("4**")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("客户端错误，请求包含语法错误或无法完成请求")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("5**")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("服务器错误，服务器在处理请求的过程中发生了错误")])])])]),t._v(" "),r("p",[r("strong",[t._v("常出现的状态码")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("状态代码")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("状态描述")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("200")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("OK")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("客户端请求成功")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("400")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("Bad Request")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("由于客户端请求有语法错误，不能被服务器所理解。")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("401")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("Unauthonzed")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("403")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("Forbidden")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("404")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("Not Found")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("请求的资源不存在，例如，输入了错误的URL。")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("500")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("Internal Server Error")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("服务器发生不可预期的错误，导致无法完成客户端的请求。")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("503")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("Service Unavailable")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。")])])])]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.zhangqifei.top/2016/01/04/%E5%B7%A5%E5%85%B7/%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考：状态码大全"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"http-mime-类型支持"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-mime-类型支持"}},[t._v("#")]),t._v(" HTTP MIME 类型支持")]),t._v(" "),r("p",[t._v("MIME, 全称为“Multipurpose Internet Mail Extensions”, 比较确切的中文名称为“多用途互联网邮件扩展”。它是当前广泛应用的一种电子邮件技术规范，基本内容定义于RFC 2045-2049")]),t._v(" "),r("p",[t._v("什么是MIME类型?-在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。")]),t._v(" "),r("p",[t._v("例 如，架设你要传送一个txt文件到客户端。那么这时的MIME类型就是“application/vnd.ms-excel”。 在大多数实际情况中，这个文件然后将传送给 Execl来处理（假设我们设定Execl为处理特殊MIME类型的应用程序）。在ASP中，设定MIME类 型的方法是通过Response对象的 ContentType属性。")]),t._v(" "),r("p",[t._v("多媒体文件格式MIME")]),t._v(" "),r("p",[t._v("最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。")]),t._v(" "),r("p",[t._v("MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。")]),t._v(" "),r("p",[t._v("每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。")]),t._v(" "),r("p",[t._v("linux服务器这个文件"),r("code",[t._v("/etc/mime.types")]),t._v("，记录着MIME类型。")]),t._v(" "),r("p",[r("a",{attrs:{href:"http://www.w3school.com.cn/media/media_mimeref.asp",target:"_blank",rel:"noopener noreferrer"}},[t._v("MIME 参考手册"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=_.exports}}]);